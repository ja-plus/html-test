<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>原生表格列宽行为</title>
</head>
<style>
  article section {
    display: flex;
    margin-bottom:20px;
    flex-wrap:wrap;
  }
  .container {
    width: 200px;
    border: 2px solid #aaa;
    overflow: auto;
  }

  table {
    border-collapse: collapse;
  }
  table caption {
    text-align:left;
  }

  table td,
  table th {
    border: 1px solid #aaa;
  }
  .fixed-table {
    table-layout: fixed;
  }
</style>

<body>
  <h2>Display: table</h2>
  <article>
    <section>
      <div class="container">
        <div style="background-color:orange;display:inline-block">inline-block最宽到父元素，自动换行自动换行自动换行自动换行自动换行</div>
      </div>
      <div class="container">
        <div style="background-color:orange;width:300px;">width:300px</div>
      </div>
    </section>
    <section>
      <div class="container">
        <table class="auto-table">
          <caption>未设置tableWidth</caption>
        </table>
      </div>
      <fieldset>
        <legend>流式布局</legend>
        <ol>
          <li>未设置table width 的情况下，table最大不超过父容器。</li>
          <li>元素的宽高由子节点决定</li>
        </ol>
      </fieldset>
    </section>
    <section>
      <div class="container">
        <table class="auto-table auto-table__max-width" style="max-width:100%">
          <caption>max-width:100%</caption>
        </table>
        <table class="auto-table auto-table__min-width" style="min-width:100%">
          <caption>min-width:100%</caption>
        </table>
        <table class="auto-table__overflow" style="min-width:100%">
          <caption>文字溢出</caption>
        </table>
      </div>
      <fieldset>
        <legend>布局</legend>
        <ol>
          <li>总列宽 大于 table宽度时， 则压缩列至minWidth，列width不生效</li>
          <li>总列宽width 小于 table宽度时， 则自动扩展列宽，使其充满table。width / max-width / min-width均不生效</li>
          <li>总列宽width 小于 table宽度时， 扩展未设置width的列</li>
          <li>table 宽度有剩余时，会分配给没设置width的列</li>
          <li>如果每一列都设置了width ，则table 宽度有剩余时，会分配给每一列</li>
          <li>min-width: 列有较高优先级，可压缩设置了width的列，设置了width的列最小可被压缩至 min-width (默认min-content)</li>
          <li>因此在table布局中，width，看作参考值，列空间充足时，不能每列都设置，空间不足时又不生效</li>
          <li>max-width: 文字撑开的最大宽度</li>
          <li>max-width: th设置最大宽度不能影响这列的td 的最大宽度，td的最大宽度需要重新指定 max-width</li>
        </ol>
      </fieldset>
    </section>
    <section>
      <div class="container">
        <b>table-layout:fixed</b>
        <table class="fixed-table"><caption>table width:initial;</caption></table>
        <table class="fixed-table fixed-table__width" style="width:150px;"><caption>table width:150px;</caption></table>
      </div>
      <fieldset>
        <legend>文字溢出</legend>
        <ol>
          <li>th设置width，overflow:hidden不生效。设置max-width解决。</li>
          <li>
            table-layout:auto/fixed区别。fixed可以设置文本溢出?
            <ul>
              <li>table-layout:fixed;列宽由表格宽度控制</li>
            </ul>
          </li>
          <li>设置table宽度，对于列较少时，不铺满表格的效果不好控制</li>
          <li>列宽度>表格宽度，table-width 不生效。因此在table-layout:fixed;中width，min-width意义相等</li>
          <li>讨论table-layout:auto 设置min-width。</li>
        </ol>
      </fieldset>
    </section>
    <section>
      <fieldset>
        <legend>小结</legend>
        <ul>
          <li>table-layout:auto;列宽总和&gt;父元素宽度，情况下，若想使table宽度大于父元素，则设置每列的min-width</li>
          <li>table-layout:auto;列宽总和&lt;父元素宽度，情况下。若想拉伸列宽，则设置表格min-width:100%</li>
          <li>table-layout:auto;列宽总和&lt;父元素宽度，情况下。若每列都设置了width，列宽被拉伸，拉伸比例根据width比例来。此时max-width可以小于width，max-width影响宽度不够时的溢出行为。</li>
          <li>table-layout:auto;列宽总和&lt;父元素宽度，情况下。若想使width生效，则至少有一列不设置width。</li>
          <li>table-layout:auto 由table列决定整体宽度。类流式布局，默认情况，宽度不大于父元素。</li>
          <li>table-layout:fixed 由table元素决定宽度。布局可以溢出父元素</li>
        </ul>
      </fieldset>
    </section>
  </article>
</body>
<script type="module">
  import h from '../js/utils/h.js';
  const autoTable = document.querySelector('.auto-table');
  const tHead = h('thead', [
    h('tr', [
      ...new Array(4).fill(0).map((it, i) => {
        return h('th', {
          textContent: String(i).repeat(2),
          // width: '30',
          style: {
            width: '30px',
            // minWidth: '60px',
            // maxWidth: '30px',
            // overflow: 'hidden',
            // textOverflow: 'ellipsis',
          },
        });
      }),
    ]),
  ]);
  const tBody = h('tbody', [
    ...new Array(2).fill(0).map((it, i) => {
      return h('tr', [
        ...new Array(4).fill(0).map((it2, j) => {
          return h('td', j);
        }),
      ]);
    }),
  ]);

  autoTable.append(tHead, tBody);
  // 同一个节点不能append到两个dom中，需要克隆，true：深克隆
  document.querySelector('.auto-table__max-width').append(tHead.cloneNode(true), tBody.cloneNode(true));
  document.querySelector('.auto-table__min-width').append(tHead.cloneNode(true), tBody.cloneNode(true));
  document.querySelector('.auto-table__overflow').append(tHead.cloneNode(true), tBody.cloneNode(true));
  document.querySelector('.fixed-table').append(tHead.cloneNode(true), tBody.cloneNode(true));
  document.querySelector('.fixed-table__width').append(tHead.cloneNode(true), tBody.cloneNode(true));
</script>

</html>