# 实时推送方案
1. 订阅，客户端推送，客户端可调用前端定义在window上的方法。
2. 客户端长连接断开。
    * 开始轮询接口。
        * 轮询前清除定时器。(防止客户端重复通知断开)
    * 轮询
        * 15s轮询一次历史数据。
        * 使用WebWorker 对比轮询数据与当前数据中，哪些数据是新增的（通过唯一键seq判断）。
    * 由于断开后会立即发送一次请求。为防止大面积连接断开时，客户端同时发送请求造成大量并发。因此
        * 对连接断开后开始轮询的请求做若干秒区间内的延迟处理。（0-4s延迟）
        * 轮询间隔在范围内随机生成。（14-18s随机）
3. 长连接重连
    * 停止轮询。
        * 清除定时器。
        * 重新请求一次基础数据。(防止轮询间隔中有新数据)
        * 进行步骤4
4. 获取基础数据返回前，有数据推送。
    * 暂存到临时数据池。（数据池是个数组）
        * 若同时推送多条相同数据，根据业务需求，选择合并/新增到数据池。
    * 基础数据返回后，将暂存区数据与基础数据合并。
    * 清空临时数据池。
5. 实时推送的数据，要根据筛选条件，前端进行过滤。
    * 推送的数据，原来在过滤条件中，现在不在，则要将原来的数据**删除**（业务上是数据更新，非数据增加的情况）。
6. 客户端推送，调用前端window上的方法，频率过快会导致调用栈堆积，导致卡顿。前端通过setInterval/setTimeout是无法模拟的。
    * 前端通过window.requestAnimationFrame 方式，将一帧中的推送数据合并到一起，再更新表格。
    * 合并帧数据时，要根据业务合并相同数据。（节流优化）
7. 暂停推送逻辑
    * 点击行后，暂停更新表格。新推送的数据，计数多少条，并展示到ui。
    * 点击查看后，重新获取历史数据。

# 表格排序和分页
* 表格滚动分页
    * 滚动到底部，用表格最后一条数据的字段请求下一页数据。
    * 滚动到顶部，用表格第一条数据的字段请求上一页数据。
* 表格排序时重置滚动条到顶部，会触发表格scroll事件。若滚动顶部加载数据的话，则会发起请求。需要注意。
   
* 表格数据裁剪。如最多保存5000条。
    * 裁剪时，注意要手动定位表格滚动条位置。
* 表格实时数据插入
    * 表格在排序状态时
        * 表格中的数据量 < 分页大小 则不用剔除数据。
        * 新增的数据插入到已有数据中。还要剔除在当前排序最小，最大值之外的新数据。为了防止获取下一页数据时，根据表格最后/最前条数据做标准获取时，返回的数据有误。
        * 若一页的最前/最后一条数据发生更新
            * 删除最前/最后一条数据。~~暂存删除数据的值~~。（特殊情况下数据不是被删完了？,删完再请求一次）
            * 加载下一页时，~~用暂存的值作为参数~~ 用最后一条数据作为参数。
        * 新数据值与~~暂存值~~最后一条数据一样，则插入表格最后方。
            * ~~此时，下页的数据可能会有重复(刚刚插入的数据)，需去重~~。
        * 第一页排序字段都是'--'的情况下，新推送的'--'数据，插入在最上方。
        * 请求下页数据返回前，也要保存实时推送的数据

