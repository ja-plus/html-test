# 实时推送方案
1. 订阅，客户端推送，客户端可调用前端定义在window上的方法。
2. 客户端长连接断开。
    * 开始轮询接口。
        * 轮询前清除定时器。(防止客户端重复通知断开)
    * 轮询
        * 15s轮询一次历史数据。
        * 使用WebWorker 对比轮询数据与当前数据中，哪些数据是新增的（通过唯一键seq判断）。
    * 由于断开后会立即发送一次请求。为防止大面积连接断开时，客户端同时发送请求造成大量并发。因此
        * 对连接断开后开始轮询的请求做若干秒区间内的延迟处理。（0-4s延迟）
        * 轮询间隔在范围内随机生成。（14-18s随机）
3. 长连接重连
    * 停止轮询。
        * 清除定时器。
        * 重新请求一次基础数据。(防止轮询间隔中有新数据)
        * 进行步骤4
4. 获取基础数据返回前，有数据推送。
    * 暂存到临时数据池。（数据池是个数组）
        * 若同时推送多条相同数据，根据业务需求，选择合并/新增到数据池。
    * **基础数据返回后**，将暂存区数据与基础数据合并。
    * 清空临时数据池。
5. 实时推送的数据，要根据筛选条件，前端进行过滤。
    * 推送的数据，原来在过滤条件中，现在不在，则要将原来的数据**删除**（业务上是数据更新，非数据增加的情况）。
6. 客户端推送，调用前端window上的方法，频率过快会导致调用栈堆积，导致卡顿。前端通过setInterval/setTimeout是无法模拟的。
    * 前端通过window.requestAnimationFrame 方式，将一帧中的推送数据合并到一起，再更新表格。
    * 合并帧数据时，要根据业务合并相同数据。（节流优化）
7. 暂停推送逻辑
    * 点击行后，暂停更新表格。新推送的数据，计数多少条，并展示到ui。
    * 点击查看后，重新获取历史数据。
    * 在暂停的时候请求下一页数据是最新的。问题如何解决。
        * 后端对某时刻数据做快照？（数据量太大）
            * 后端对每条数据记录入库时间，前端请求某时间前的所有数据？（数据时间会更新，不适用）
        * 前端点击暂停推送后，请求接口获取下面**若干页**数据（不是所有）。、
            * 此时获取这几页的数据已经不是旧的了？

# 表格排序和分页
* 表格滚动分页
    * 滚动到底部，用表格最后一条数据的字段请求下一页数据。
    * 滚动到顶部，用表格第一条数据的字段请求上一页数据。
* 表格排序时重置滚动条到顶部，会触发表格scroll事件。若滚动顶部加载数据的话，则会发起请求。需要注意。
   
* 表格数据裁剪。如最多保存5000条。
    * 裁剪时，注意要手动定位表格滚动条位置。
* 表格实时数据插入
    * 新数据插入到表格，表中相同的老数据删除。再进行表格排序。（表格默认根据时间倒序）
    * 表格在排序状态时
        * 表格中的数据量 < 分页大小 则不用剔除数据。
        * 新增的数据插入到已有数据中。还要剔除在当前排序最小，最大值之外的新数据。为了防止获取下一页数据时，根据表格最后/最前条数据做标准获取时，返回的数据有误。
        * ~~若一页的最前/最后一条数据发生更新。~~
            * 删除最前/最后一条数据。~~暂存删除数据的值~~，再看新数据是否在排序区间，是则插入。（特殊情况下数据不是被删完了？,删完再请求一次）
            * 加载下一页时，~~用暂存的值作为参数~~ 用最后一条数据作为参数。
        * 分页基准数据变更，保证下页数据准确性。
            * 定义分页基准数据指针，初始指向当页最后一条。
            * 最后一条数据更新。
                * 插入在排序值之上，则正常插入。
                * 插入在排序值之下，则插入后，指针向上移动一位。
                    * 直到指针位置到0，则重刷表格所有数据。页大小，需保持一致。（特殊情况下，用户感知整页数据发生变化。）
                * 插入值与替换值的排序值**相等**
                    * 比较另外一个唯一值，确认插入位置。（需要和后端确认排序规则。一般order by 排序值&唯一值）
                    * 同上比较插入在目标之上还是之下。
            * 请求下一页数据时
                * 取指针位置，将其之后的数据删除。请求pageSize = 删除的数据 + pageSize。
                * 还原指针位置，到最后一条。
        * 新数据值与~~暂存值~~最后一条数据一样，则插入表格最后方。
        * 第一页排序字段都是'--'的情况下，新推送的'--'数据，根据唯一值排序，一般插入在最上方。
        * 请求下页数据返回前，也要保存实时推送的数据。
        * 下页的数据要和当前页数据做去重处理。
            * 考虑上一页最后一条数据变化推送未收到的情况。
            * 插入的数据排序值与最后一条一样的情况。（这里后端可能会漏部分数据）
    * 若表格排序，但是要求**新数据不插入**，仅更新现有的数据时。
        * 分页肯定是有问题的。下一页通过上一页最后一条数据为基准获取。若上一页最后一条数据发生变化，则获取的下一页数据有误。

